{"ast":null,"code":"import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { Delaunay } from 'd3-delaunay';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport { InteractionContext } from '../context/InteractionProvider';\nimport { CartesianContext } from '../context/CartesianContextProvider';\nimport { SvgContext, DrawingContext } from '../context/DrawingProvider';\nimport { SeriesContext } from '../context/SeriesContextProvider';\nimport { getValueToPositionMapper } from '../hooks/useScale';\nimport { getSVGPoint } from '../internals/utils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction ChartsVoronoiHandler(props) {\n  const {\n    voronoiMaxRadius,\n    onItemClick\n  } = props;\n  const svgRef = React.useContext(SvgContext);\n  const {\n    width,\n    height,\n    top,\n    left\n  } = React.useContext(DrawingContext);\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = React.useContext(CartesianContext);\n  const {\n    dispatch\n  } = React.useContext(InteractionContext);\n  const {\n    series,\n    seriesOrder\n  } = React.useContext(SeriesContext).scatter ?? {};\n  const voronoiRef = React.useRef({});\n  const delauneyRef = React.useRef(undefined);\n  const defaultXAxisId = xAxisIds[0];\n  const defaultYAxisId = yAxisIds[0];\n  useEnhancedEffect(() => {\n    dispatch({\n      type: 'updateVoronoiUsage',\n      useVoronoiInteraction: true\n    });\n    return () => {\n      dispatch({\n        type: 'updateVoronoiUsage',\n        useVoronoiInteraction: false\n      });\n    };\n  }, [dispatch]);\n  useEnhancedEffect(() => {\n    // This effect generate and store the Delaunay object that's used to map coordinate to closest point.\n\n    if (seriesOrder === undefined || series === undefined) {\n      // If there is no scatter chart series\n      return;\n    }\n    voronoiRef.current = {};\n    let points = [];\n    seriesOrder.forEach(seriesId => {\n      const {\n        data,\n        xAxisKey,\n        yAxisKey\n      } = series[seriesId];\n      const xScale = xAxis[xAxisKey ?? defaultXAxisId].scale;\n      const yScale = yAxis[yAxisKey ?? defaultYAxisId].scale;\n      const getXPosition = getValueToPositionMapper(xScale);\n      const getYPosition = getValueToPositionMapper(yScale);\n      const seriesPoints = data.flatMap(({\n        x,\n        y\n      }) => [getXPosition(x), getYPosition(y)]);\n      voronoiRef.current[seriesId] = {\n        seriesId,\n        startIndex: points.length,\n        endIndex: points.length + seriesPoints.length\n      };\n      points = points.concat(seriesPoints);\n    });\n    delauneyRef.current = new Delaunay(points);\n  }, [defaultXAxisId, defaultYAxisId, series, seriesOrder, xAxis, yAxis]);\n  React.useEffect(() => {\n    const element = svgRef.current;\n    if (element === null) {\n      return undefined;\n    }\n\n    // TODO: A perf optimisation of voronoi could be to use the last point as the initial point for the next search.\n    function getClosestPoint(event) {\n      // Get mouse coordinate in global SVG space\n      const svgPoint = getSVGPoint(svgRef.current, event);\n      const outsideX = svgPoint.x < left || svgPoint.x > left + width;\n      const outsideY = svgPoint.y < top || svgPoint.y > top + height;\n      if (outsideX || outsideY) {\n        return 'outside-chart';\n      }\n      if (!delauneyRef.current) {\n        return 'no-point-found';\n      }\n      const closestPointIndex = delauneyRef.current.find(svgPoint.x, svgPoint.y);\n      if (closestPointIndex === undefined) {\n        return 'no-point-found';\n      }\n      const closestSeries = Object.values(voronoiRef.current).find(value => {\n        return 2 * closestPointIndex >= value.startIndex && 2 * closestPointIndex < value.endIndex;\n      });\n      if (closestSeries === undefined) {\n        return 'no-point-found';\n      }\n      const dataIndex = (2 * closestPointIndex - voronoiRef.current[closestSeries.seriesId].startIndex) / 2;\n      if (voronoiMaxRadius !== undefined) {\n        const pointX = delauneyRef.current.points[2 * closestPointIndex];\n        const pointY = delauneyRef.current.points[2 * closestPointIndex + 1];\n        const dist2 = (pointX - svgPoint.x) ** 2 + (pointY - svgPoint.y) ** 2;\n        if (dist2 > voronoiMaxRadius ** 2) {\n          // The closest point is too far to be considered.\n          return 'outside-voronoi-max-radius';\n        }\n      }\n      return {\n        seriesId: closestSeries.seriesId,\n        dataIndex\n      };\n    }\n    const handleMouseOut = () => {\n      dispatch({\n        type: 'exitChart'\n      });\n    };\n    const handleMouseMove = event => {\n      const closestPoint = getClosestPoint(event);\n      if (closestPoint === 'outside-chart') {\n        dispatch({\n          type: 'exitChart'\n        });\n        return;\n      }\n      if (closestPoint === 'outside-voronoi-max-radius' || closestPoint === 'no-point-found') {\n        dispatch({\n          type: 'leaveItem',\n          data: {\n            type: 'scatter'\n          }\n        });\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      dispatch({\n        type: 'enterItem',\n        data: {\n          type: 'scatter',\n          seriesId,\n          dataIndex\n        }\n      });\n    };\n    const handleMouseClick = event => {\n      if (!onItemClick) {\n        return;\n      }\n      const closestPoint = getClosestPoint(event);\n      if (typeof closestPoint === 'string') {\n        // No point fond for any reason\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      onItemClick(event, {\n        type: 'scatter',\n        seriesId,\n        dataIndex\n      });\n    };\n    element.addEventListener('mouseout', handleMouseOut);\n    element.addEventListener('mousemove', handleMouseMove);\n    element.addEventListener('click', handleMouseClick);\n    return () => {\n      element.removeEventListener('mouseout', handleMouseOut);\n      element.removeEventListener('mousemove', handleMouseMove);\n      element.removeEventListener('click', handleMouseClick);\n    };\n  }, [svgRef, dispatch, left, width, top, height, yAxis, xAxis, voronoiMaxRadius, onItemClick]);\n\n  // eslint-disable-next-line react/jsx-no-useless-fragment\n  return /*#__PURE__*/_jsx(React.Fragment, {});\n}\nprocess.env.NODE_ENV !== \"production\" ? ChartsVoronoiHandler.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\r\n   * Callback fired when clicking on a scatter item.\r\n   * @param {MouseEvent} event Mouse event caught at the svg level\r\n   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked\r\n   */\n  onItemClick: PropTypes.func,\n  /**\r\n   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.\r\n   * If `undefined`, the radius is assumed to be infinite.\r\n   */\n  voronoiMaxRadius: PropTypes.number\n} : void 0;\nexport { ChartsVoronoiHandler };","map":{"version":3,"names":["React","PropTypes","Delaunay","useEnhancedEffect","InteractionContext","CartesianContext","SvgContext","DrawingContext","SeriesContext","getValueToPositionMapper","getSVGPoint","jsx","_jsx","ChartsVoronoiHandler","props","voronoiMaxRadius","onItemClick","svgRef","useContext","width","height","top","left","xAxis","yAxis","xAxisIds","yAxisIds","dispatch","series","seriesOrder","scatter","voronoiRef","useRef","delauneyRef","undefined","defaultXAxisId","defaultYAxisId","type","useVoronoiInteraction","current","points","forEach","seriesId","data","xAxisKey","yAxisKey","xScale","scale","yScale","getXPosition","getYPosition","seriesPoints","flatMap","x","y","startIndex","length","endIndex","concat","useEffect","element","getClosestPoint","event","svgPoint","outsideX","outsideY","closestPointIndex","find","closestSeries","Object","values","value","dataIndex","pointX","pointY","dist2","handleMouseOut","handleMouseMove","closestPoint","handleMouseClick","addEventListener","removeEventListener","Fragment","process","env","NODE_ENV","propTypes","func","number"],"sources":["C:/Users/maria/Desktop/Loppuprojekti/frontend/node_modules/@mui/x-charts/esm/ChartsVoronoiHandler/ChartsVoronoiHandler.js"],"sourcesContent":["import * as React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { Delaunay } from 'd3-delaunay';\r\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\r\nimport { InteractionContext } from '../context/InteractionProvider';\r\nimport { CartesianContext } from '../context/CartesianContextProvider';\r\nimport { SvgContext, DrawingContext } from '../context/DrawingProvider';\r\nimport { SeriesContext } from '../context/SeriesContextProvider';\r\nimport { getValueToPositionMapper } from '../hooks/useScale';\r\nimport { getSVGPoint } from '../internals/utils';\r\nimport { jsx as _jsx } from \"react/jsx-runtime\";\r\nfunction ChartsVoronoiHandler(props) {\r\n  const {\r\n    voronoiMaxRadius,\r\n    onItemClick\r\n  } = props;\r\n  const svgRef = React.useContext(SvgContext);\r\n  const {\r\n    width,\r\n    height,\r\n    top,\r\n    left\r\n  } = React.useContext(DrawingContext);\r\n  const {\r\n    xAxis,\r\n    yAxis,\r\n    xAxisIds,\r\n    yAxisIds\r\n  } = React.useContext(CartesianContext);\r\n  const {\r\n    dispatch\r\n  } = React.useContext(InteractionContext);\r\n  const {\r\n    series,\r\n    seriesOrder\r\n  } = React.useContext(SeriesContext).scatter ?? {};\r\n  const voronoiRef = React.useRef({});\r\n  const delauneyRef = React.useRef(undefined);\r\n  const defaultXAxisId = xAxisIds[0];\r\n  const defaultYAxisId = yAxisIds[0];\r\n  useEnhancedEffect(() => {\r\n    dispatch({\r\n      type: 'updateVoronoiUsage',\r\n      useVoronoiInteraction: true\r\n    });\r\n    return () => {\r\n      dispatch({\r\n        type: 'updateVoronoiUsage',\r\n        useVoronoiInteraction: false\r\n      });\r\n    };\r\n  }, [dispatch]);\r\n  useEnhancedEffect(() => {\r\n    // This effect generate and store the Delaunay object that's used to map coordinate to closest point.\r\n\r\n    if (seriesOrder === undefined || series === undefined) {\r\n      // If there is no scatter chart series\r\n      return;\r\n    }\r\n    voronoiRef.current = {};\r\n    let points = [];\r\n    seriesOrder.forEach(seriesId => {\r\n      const {\r\n        data,\r\n        xAxisKey,\r\n        yAxisKey\r\n      } = series[seriesId];\r\n      const xScale = xAxis[xAxisKey ?? defaultXAxisId].scale;\r\n      const yScale = yAxis[yAxisKey ?? defaultYAxisId].scale;\r\n      const getXPosition = getValueToPositionMapper(xScale);\r\n      const getYPosition = getValueToPositionMapper(yScale);\r\n      const seriesPoints = data.flatMap(({\r\n        x,\r\n        y\r\n      }) => [getXPosition(x), getYPosition(y)]);\r\n      voronoiRef.current[seriesId] = {\r\n        seriesId,\r\n        startIndex: points.length,\r\n        endIndex: points.length + seriesPoints.length\r\n      };\r\n      points = points.concat(seriesPoints);\r\n    });\r\n    delauneyRef.current = new Delaunay(points);\r\n  }, [defaultXAxisId, defaultYAxisId, series, seriesOrder, xAxis, yAxis]);\r\n  React.useEffect(() => {\r\n    const element = svgRef.current;\r\n    if (element === null) {\r\n      return undefined;\r\n    }\r\n\r\n    // TODO: A perf optimisation of voronoi could be to use the last point as the initial point for the next search.\r\n    function getClosestPoint(event) {\r\n      // Get mouse coordinate in global SVG space\r\n      const svgPoint = getSVGPoint(svgRef.current, event);\r\n      const outsideX = svgPoint.x < left || svgPoint.x > left + width;\r\n      const outsideY = svgPoint.y < top || svgPoint.y > top + height;\r\n      if (outsideX || outsideY) {\r\n        return 'outside-chart';\r\n      }\r\n      if (!delauneyRef.current) {\r\n        return 'no-point-found';\r\n      }\r\n      const closestPointIndex = delauneyRef.current.find(svgPoint.x, svgPoint.y);\r\n      if (closestPointIndex === undefined) {\r\n        return 'no-point-found';\r\n      }\r\n      const closestSeries = Object.values(voronoiRef.current).find(value => {\r\n        return 2 * closestPointIndex >= value.startIndex && 2 * closestPointIndex < value.endIndex;\r\n      });\r\n      if (closestSeries === undefined) {\r\n        return 'no-point-found';\r\n      }\r\n      const dataIndex = (2 * closestPointIndex - voronoiRef.current[closestSeries.seriesId].startIndex) / 2;\r\n      if (voronoiMaxRadius !== undefined) {\r\n        const pointX = delauneyRef.current.points[2 * closestPointIndex];\r\n        const pointY = delauneyRef.current.points[2 * closestPointIndex + 1];\r\n        const dist2 = (pointX - svgPoint.x) ** 2 + (pointY - svgPoint.y) ** 2;\r\n        if (dist2 > voronoiMaxRadius ** 2) {\r\n          // The closest point is too far to be considered.\r\n          return 'outside-voronoi-max-radius';\r\n        }\r\n      }\r\n      return {\r\n        seriesId: closestSeries.seriesId,\r\n        dataIndex\r\n      };\r\n    }\r\n    const handleMouseOut = () => {\r\n      dispatch({\r\n        type: 'exitChart'\r\n      });\r\n    };\r\n    const handleMouseMove = event => {\r\n      const closestPoint = getClosestPoint(event);\r\n      if (closestPoint === 'outside-chart') {\r\n        dispatch({\r\n          type: 'exitChart'\r\n        });\r\n        return;\r\n      }\r\n      if (closestPoint === 'outside-voronoi-max-radius' || closestPoint === 'no-point-found') {\r\n        dispatch({\r\n          type: 'leaveItem',\r\n          data: {\r\n            type: 'scatter'\r\n          }\r\n        });\r\n        return;\r\n      }\r\n      const {\r\n        seriesId,\r\n        dataIndex\r\n      } = closestPoint;\r\n      dispatch({\r\n        type: 'enterItem',\r\n        data: {\r\n          type: 'scatter',\r\n          seriesId,\r\n          dataIndex\r\n        }\r\n      });\r\n    };\r\n    const handleMouseClick = event => {\r\n      if (!onItemClick) {\r\n        return;\r\n      }\r\n      const closestPoint = getClosestPoint(event);\r\n      if (typeof closestPoint === 'string') {\r\n        // No point fond for any reason\r\n        return;\r\n      }\r\n      const {\r\n        seriesId,\r\n        dataIndex\r\n      } = closestPoint;\r\n      onItemClick(event, {\r\n        type: 'scatter',\r\n        seriesId,\r\n        dataIndex\r\n      });\r\n    };\r\n    element.addEventListener('mouseout', handleMouseOut);\r\n    element.addEventListener('mousemove', handleMouseMove);\r\n    element.addEventListener('click', handleMouseClick);\r\n    return () => {\r\n      element.removeEventListener('mouseout', handleMouseOut);\r\n      element.removeEventListener('mousemove', handleMouseMove);\r\n      element.removeEventListener('click', handleMouseClick);\r\n    };\r\n  }, [svgRef, dispatch, left, width, top, height, yAxis, xAxis, voronoiMaxRadius, onItemClick]);\r\n\r\n  // eslint-disable-next-line react/jsx-no-useless-fragment\r\n  return /*#__PURE__*/_jsx(React.Fragment, {});\r\n}\r\nprocess.env.NODE_ENV !== \"production\" ? ChartsVoronoiHandler.propTypes = {\r\n  // ----------------------------- Warning --------------------------------\r\n  // | These PropTypes are generated from the TypeScript type definitions |\r\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\r\n  // ----------------------------------------------------------------------\r\n  /**\r\n   * Callback fired when clicking on a scatter item.\r\n   * @param {MouseEvent} event Mouse event caught at the svg level\r\n   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked\r\n   */\r\n  onItemClick: PropTypes.func,\r\n  /**\r\n   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.\r\n   * If `undefined`, the radius is assumed to be infinite.\r\n   */\r\n  voronoiMaxRadius: PropTypes.number\r\n} : void 0;\r\nexport { ChartsVoronoiHandler };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}